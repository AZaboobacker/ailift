name: Deploy to AWS Elastic Beanstalk

on:
  push:
    paths:
      - '**/**'

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 2  # Ensure we fetch enough history to access HEAD^

    - name: Find new folder
      id: newfolder
      run: |
        git fetch --depth=2
        NEW_FOLDER=$(git diff --name-only HEAD^ HEAD | grep -oE '^[^/]+/' | sort -u | head -n 1)
        echo "NEW_FOLDER=${NEW_FOLDER}" >> $GITHUB_ENV
      shell: bash

    - name: Debug new folder
      run: echo "New folder is:${{ env.NEW_FOLDER }}"
      shell: bash

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.8'

    - name: Install dependencies
      run: |
        cd ${{ env.NEW_FOLDER }}
        if [ -f requirements.txt ]; then
          python -m pip install --upgrade pip
          pip install -r requirements.txt
        else
          echo "No requirements.txt found in the new folder."
          exit 1
        fi
      shell: bash

    # Debug step to print out the secrets
    - name: Debug Secrets
      run: |
        echo "AWS_REGION: ${{ secrets.AWS_REGION }}"
        echo "S3_BUCKET: ${{ secrets.S3_BUCKET }}"
        echo "VPC_ID: ${{ secrets.VPC_ID }}"
        echo "SUBNET1: ${{ secrets.SUBNET1 }}"
        echo "SUBNET2: ${{ secrets.SUBNET2 }}"
      shell: bash

    - name: Format Subnets
      id: format_subnets
      run: |
        SUBNETS_STRING="${{ secrets.SUBNET1 }},${{ secrets.SUBNET2 }}"
        echo "SUBNETS_STRING=$SUBNETS_STRING" >> $GITHUB_ENV
      shell: bash

    - name: Debug Formatted Subnets
      run: |
        echo "Formatted SUBNETS:${{ env.SUBNETS_STRING }}"
      shell: bash

    - name: Deploy to AWS Elastic Beanstalk
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_REGION: ${{ secrets.AWS_REGION }}
        S3_BUCKET: ${{ secrets.S3_BUCKET }}
        VPC_ID: ${{ secrets.VPC_ID }}
        SUBNETS: ${{ env.SUBNETS_STRING }}
      run: |
        UNIQUE_ID=$(uuidgen)
        DIRECTORY="${UNIQUE_ID}-app"
        
        # Create a directory for the app
        mkdir $DIRECTORY

        # Copy Streamlit app code into the directory
        cp ${{ env.NEW_FOLDER }}streamlit.py $DIRECTORY/app.py
        cp ${{ env.NEW_FOLDER }}requirements.txt $DIRECTORY/

        # Navigate to the app directory
        cd $DIRECTORY

        # Create a Procfile for the app
        echo "web: streamlit run app.py --server.port \$PORT" > Procfile

        # Zip the application
        cd ..
        zip -r ${UNIQUE_ID}.zip $DIRECTORY

        # Upload the application to S3
        aws s3 cp ${UNIQUE_ID}.zip s3://${S3_BUCKET}/${UNIQUE_ID}.zip

        # Create an Elastic Beanstalk application
        aws elasticbeanstalk create-application --application-name "${UNIQUE_ID}-app"

        # Create an Elastic Beanstalk application version
        aws elasticbeanstalk create-application-version --application-name "${UNIQUE_ID}-app" --version-label "${UNIQUE_ID}" --source-bundle S3Bucket=${S3_BUCKET},S3Key=${UNIQUE_ID}.zip

        # Create an Elastic Beanstalk environment with an instance profile and VPC settings
        aws elasticbeanstalk create-environment --application-name "${UNIQUE_ID}-app" --environment-name "${UNIQUE_ID}-env" --version-label "${UNIQUE_ID}" --solution-stack-name "64bit Amazon Linux 2 v3.3.14 running Python 3.8" \
          --option-settings Namespace=aws:autoscaling:launchconfiguration,OptionName=IamInstanceProfile,Value=aws-elasticbeanstalk-ec2-role \
          --option-settings Namespace=aws:ec2:vpc,OptionName=VPCId,Value=${{ secrets.VPC_ID }} \
          --option-settings Namespace=aws:ec2:vpc,OptionName=Subnets,Value=${{ secrets.SUBNET1 }} \
          --option-settings Namespace=aws:ec2:vpc,OptionName=ELBSubnets,Value=${{ secrets.SUBNET1 }}

        # Wait for the environment to be ready
        MAX_ATTEMPTS=30
        SLEEP_INTERVAL=60
        ATTEMPT=0
        while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
          STATUS=$(aws elasticbeanstalk describe-environments --environment-names "${UNIQUE_ID}-env" --query "Environments[0].Status" --output text)
          echo "Attempt $((ATTEMPT+1))/$MAX_ATTEMPTS: Environment status is $STATUS"
          if [ "$STATUS" == "Ready" ]; then
            echo "Environment is ready!"
            break
          fi
          if [ "$STATUS" == "Terminated" ] || [ "$STATUS" == "Terminating" ]; then
            echo "Environment creation failed or is terminating. Exiting..."
            exit 1
          fi
          ATTEMPT=$((ATTEMPT+1))
          sleep $SLEEP_INTERVAL
        done

        if [ $ATTEMPT -eq $MAX_ATTEMPTS]; then
          echo "Max attempts reached. Environment did not become ready in time."
          exit 1
        fi

        # Get the environment URL
        ENV_URL=$(aws elasticbeanstalk describe-environments --application-name "${UNIQUE_ID}-app" --environment-names "${UNIQUE_ID}-env" --query "Environments[0].CNAME" --output text)
        echo "ENV_URL=http://$ENV_URL" >> $GITHUB_ENV

    - name: Print URL
      run: echo "The Streamlit app is deployed at:${{ env.ENV_URL }}"
      shell: bash
